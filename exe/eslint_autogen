#!/usr/bin/env ruby
# frozen_string_literal: true

require 'active_support/all'
require 'stringio'

TODO_FILE_PATH = './.eslint_todo.mts'
HEADING = <<~COMMENTS.freeze
  // This configuration was generated by `exe/eslint_autogen`
  // on #{Time.now.utc}.
  // The point is for the user to remove these configuration records
  // one by one as the offenses are removed from the code base.
COMMENTS
MAX_FILES_FOR_OVERRIDES = 4_000_000

File.write(TODO_FILE_PATH, "export default [];\n")
json = `pnpm --silent eslint --format json`
results = JSON.parse(json)

by_rule =
  results.each_with_object({}) do |result, hash|
    result.fetch('messages').each do |message|
      rule_id = message.fetch('ruleId')
      next if rule_id.nil?

      hash[rule_id] ||= []
      hash[rule_id] << result.fetch('filePath')
    end
  end

overrides, disables =
  by_rule.sort_by(&:first).partition do |_rule, file_paths|
    file_paths.uniq.length <= MAX_FILES_FOR_OVERRIDES
  end

output = StringIO.new
output.puts(HEADING)
output.puts('export default [')

overrides.each do |rule, file_paths|
  unique_files = file_paths.uniq.sort
  output.puts
  output.puts("  // Offense count: #{file_paths.length}")
  output.puts('  {')

  if unique_files.length == 1
    output.puts("    files: ['#{unique_files.first.sub("#{Dir.pwd}/", '')}'],")
  else
    output.puts('    files: [')
    unique_files.each do |file_path|
      output.puts("      '#{file_path.sub("#{Dir.pwd}/", '')}',")
    end
    output.puts('    ],')
  end

  output.puts("    rules: { '#{rule}': 'off' },")
  output.puts('  },')
end

if disables.any?
  output.puts
  output.puts('  // Rules disabled globally due to too many files')

  disables.each do |rule, file_paths|
    output.puts
    output.puts("  // Offense count: #{file_paths.length}")
    output.puts('  {')
    output.puts("    rules: { '#{rule}': 'off' },")
    output.puts('  },')
  end
end

output.puts('];')

File.write(TODO_FILE_PATH, output.string)
